//@author: a0114847b



	/**
	 * origin: .\udo\language\EnglishLanguagePack.java
	 */

package udo.language;

public class EnglishLanguagePack extends LanguagePack {
	
	@Override
	public void setLanguage() {
		
		// Commands
		ADD = "add";
		LIST = "list";
		DELETE = "delete";
		SAVE = "save";
		EXIT = "exit";
		UNDO = "undo";
		EDIT = "edit";
		MARK_DONE = "done";
		TOGGLE_DONE = "toggle";
		SEARCH = "search";
		
		// Keywords
		FROM = "from";
		TO = "to";
		BY = "by";
		
		// Time words
		YESTERDAY = "yesterday";
		TODAY = "today";
		TONIGHT = "tonight";
		SUNDAY = "sunday";
		MONDAY = "monday";
		TUESDAY = "tuesday";
		WEDNESDAY = "wednesday";
		THURSDAY = "thursday";
		FRIDAY = "friday";
		SATURDAY = "saturday";
		TOMORROW = "tomorrow";
		
		// Edit fields
		TITLE = "title";
		START_TIME = "start time";
		END_TIME = "end time";
		START_DATE = "start date";
		END_DATE = "end date";
		DUE_TIME = "due time";
		DUE_DATE = "due date";

		// list queries
		DAY = "day";
		ALL = "all";
		EVENT = "event";
		TASK = "task";
		PLAN = "plan";
		DONE = "done";
		
		// Welcome messages
		WELCOME_MESSAGE = "Welcome to uDo!";
		SUB_WELCOME_MESSAGE = "Start by typing in the textbox below:";
		
		// Popup messages
		POPUP_ADDED = "Added ";
		POPUP_DELETED = "Deleted ";
		POPUP_EDITED = "Edited ";
		POPUP_SAVED = "Saved ";
		POPUP_PARSING_FAIL = "Command not recognised. Please try again";
		POPUP_EXEC_FAIL = "Command cannot be executed. Please try again";
		POPUP_TOGGLE_DONE = "Toggled completion status of ";
		POPUP_MARK_AS_DONE = "Marked as done: ";
		POPUP_NO_ITEMS_FOUND = "No items found";
		POPUP_LIST = "Listing ";
		POPUP_SEARCH = "Search result for ";
		POPUP_QUERY_ALL = "all items";
		POPUP_QUERY_DONE = "items that have been marked as done";
		POPUP_QUERY_DATE = "items on ";
		POPUP_QUERY_EVENT = "all events";
		POPUP_QUERY_PLAN = "all plans";
		POPUP_QUERY_TASK = "all tasks";
		
		// DayScreen messages
		FREE_TODAY = "You are free today!";
		
		// ToDoScreen messages
		TO_DO_TITLE = "To Do";
		NO_UPCOMING_TASKS = "You have no upcoming tasks!";
		
		// SingleView messages
		SINGLE_MARK_AS_DONE = "You have marked the following as completed: ";
		SINGLE_TOGGLE_DONE = "You have toggled the completion status of: ";
		SINGLE_EDITED = "You have edited: ";
		SINGLE_FROM = "from: ";
		SINGLE_TO = "to: ";
		SINGLE_THIS_IS_EDITED_ITEM = "This is the edited item: ";
		SINGLE_SUCCESFULLY_ADDED = "You have successfully added: ";
		SINGLE_SUCCESSFULLY_DELETED = "You have successfully deleted: ";
		
		// Months
		JANUARY = "January";
		FEBRUARY = "February";
		MARCH = "March";
		APRIL = "April";
		MAY = "May";
		JUNE = "June";
		JULY = "July";
		AUGUST = "August";
		SEPTEMBER = "September";
		OCTOBER = "October";
		NOVEMBER = "November";
		DECEMBER = "December";
		
		//Abbreviated Months
		JAN = "Jan";
		FEB = "Feb";
		MAR = "Mar";
		APR = "Apr";
		MAY_SHORT = "May";
		JUN = "Jun";
		JUL = "Jul";
		AUG = "Aug";
		SEP = "Sep";
		OCT = "Oct";
		NOV = "Nov";
		DEC = "Dec";
		
		
	}
	
}
	// End of segment: .\udo\language\EnglishLanguagePack.java





	/**
	 * origin: .\udo\language\LanguagePack.java
	 */

package udo.language;

/**
 * This class is an abstract class that has to be extended. 
 * <p>
 * Extend this class by making a language class that gives values 
 * to all the language variables. 
 * <p>
 * Assign the USER_LANGUAGE_PACK variable to the class you extended.
 *
 */
public abstract class LanguagePack {
	
	public static final LanguagePack USER_LANGUAGE_PACK =
			// replace this with the desired LanguagePack
			// new IndonesianLanguagePack();
			new EnglishLanguagePack();
	
	
	
	
	/********************************************************
	 * To Language translators: do not touch the code below *
	 ********************************************************/
	
	/**
	 * This method returns a LanguagePack object that represents the current user's
	 * desired language.
	 * @return the implemented LanguagePack object 
	 */
	public static LanguagePack getInstance() {
		USER_LANGUAGE_PACK.setLanguage();
		return USER_LANGUAGE_PACK;
	}
	
	/**
	 * This method must be overridden in the extending class. The method should
	 * contain variable assignments that set the language variables. 
	 */
	public abstract void setLanguage();
	
	
	// the following language variables hold the string values for 
	// their equivalent in english. The must be overridden 
	// in the extended class in the setLanguage() method. 
	
	// commands
	protected String ADD;
	protected String LIST;
	protected String DELETE;
	protected String SAVE;
	protected String EXIT;
	protected String UNDO;
	protected String EDIT;
	protected String MARK_DONE;
	protected String TOGGLE_DONE;
	protected String SEARCH;
	
	// keywords
	protected String FROM;
	protected String TO;
	protected String BY;
	
	// time words
	protected String YESTERDAY;
	protected String TODAY;
	protected String TONIGHT;
	protected String SUNDAY;
	protected String MONDAY;
	protected String TUESDAY;
	protected String WEDNESDAY;
	protected String THURSDAY;
	protected String FRIDAY;
	protected String SATURDAY;
	protected String TOMORROW;
	
	// edit fields
	protected String TITLE;
	protected String START_TIME;
	protected String END_TIME;
	protected String START_DATE;
	protected String END_DATE;
	protected String DUE_TIME;
	protected String DUE_DATE;

	// list queries
	protected String DAY;
	protected String ALL;
	protected String EVENT;
	protected String TASK;
	protected String PLAN;
	protected String DONE;
	
	// End of segment: .\udo\language\LanguagePack.java





	/**
	 * origin: .\udo\main\Parser.java
	 */

package udo.main;

import udo.language.LanguagePack;
import udo.util.parser.Action;
import udo.util.parser.AddAction;
import udo.util.parser.DeleteAction;
import udo.util.parser.EditAction;
import udo.util.parser.ExitAction;
import udo.util.parser.ListAction;
import udo.util.parser.MarkAction;
import udo.util.parser.SaveAction;
import udo.util.parser.SearchAction;
import udo.util.parser.ToggleDoneAction;
import udo.util.parser.TrashAction;
import udo.util.parser.UndoAction;
import udo.util.shared.Command;
import udo.util.shared.InputData;

/**
 * This class parses information from the input string and package it 
 * as an InputData object. 
 * <p>
 * It reads all enum Command commands.
 * Parser stores the keys using Keys class constants. 
 */

public class Parser {
	
	private LanguagePack mLang;
	
	public Parser() {
		mLang = LanguagePack.getInstance();
	}
	
	/**
	 * Parses raw user's input and return it as an InputData object.
	 * Fields are filled accordingly to commands, which is the first word in the string
	 * 
	 * @param input string 
	 * @return InputData object
	 */
	public InputData getInputData(String input) {
		Command type = determineCommandType(input);
		InputData data = processCommandType(type, input);
		return data;
	}
	
	private Command determineCommandType(String input) {
		input = input.toLowerCase();
		String parts[] = input.split(" ");
		String command = parts[0];
		command = command.toLowerCase();
		
		if (command.equals(mLang.getADD())) {
			return Command.ADD;
			
		} else if (command.equals(mLang.getLIST())) {
			return Command.LIST;
			
		} else if (command.equals(mLang.getDELETE())) {
			return Command.DELETE;
			
		} else if (command.equals(mLang.getSAVE())) {
			return Command.SAVE;
			
		} else if (command.equals(mLang.getEXIT())) {
			return Command.EXIT;
			
		} else if (command.equals(mLang.getUNDO())) {
			return Command.UNDO;
			
		} else if (command.equals(mLang.getEDIT())) {
			return Command.EDIT;
			
		} else if (command.equals(mLang.getMARK_DONE())) {
			return Command.MARK_DONE;
			
		} else if (command.equals(mLang.getTOGGLE_DONE())) {
			return Command.TOGGLE_DONE;
			
		} else if (command.equals(mLang.getSEARCH())) {
			return Command.SEARCH;
			
		} else {
			return Command.NULL;
		}
	}

	private InputData processCommandType(Command commandType, String details) {
		switch (commandType) {
			case ADD :
				return add(commandType, details);
				
			case LIST :
				return list(commandType, details);
				
			case DELETE :
				return delete(commandType, details);
				
			case SAVE :
				return save(commandType, details);
				
			case EXIT :
				return exit(commandType, details);
				
			case UNDO :
				return undo(commandType, details);
				
			case EDIT :
				return edit(commandType, details);
				
			case TOGGLE_DONE :
				return toggle_done(commandType, details);
				
			case MARK_DONE :
				return mark(commandType, details);
				
			case SEARCH :
				return search(commandType, details);
				
			default:
				return trash(commandType, details);
			}
	}
	
	private InputData search(Command type, String details) {
		Action search = new SearchAction();
		InputData data = search.run(type, details);
		return data;
	}

	private InputData mark(Command type, String details) {
		Action mark = new MarkAction();
		InputData data = mark.run(type, details);
		return data;
	}

	private InputData toggle_done(Command type, String details) {
		Action toggleDone = new ToggleDoneAction();
		InputData data = toggleDone.run(type, details);
		return data;
	}

	private InputData add(Command type, String details) {
		Action add = new AddAction();
		InputData data = add.run(type, details);
		return data;
	}
	
	private InputData list(Command type, String details) {
		Action list = new ListAction();
		InputData data = list.run(type, details);
		return data;
	}

	private InputData edit(Command type, String details) {
		Action edit = new EditAction();
		InputData data = edit.run(type, details);
		return data;
	}
	
	private InputData delete(Command type, String details) {
		Action delete = new DeleteAction();
		InputData data = delete.run(type, details);
		return data;
	}
	
	private InputData trash(Command type, String details) {
		Action trash = new TrashAction();
		InputData data = trash.run(type);
		return data;
	}

	private InputData undo(Command type, String details) {
		Action undo = new UndoAction();
		InputData data = undo.run(type);
		return data;
	}

	private InputData save(Command type, String details) {
		Action save = new SaveAction();
		InputData data = save.run(type);
		return data;
	}

	private InputData exit(Command type, String details) {
		Action exit = new ExitAction();
		InputData data = exit.run(type);
		return data;
	}
}

	// End of segment: .\udo\main\Parser.java





	/**
	 * origin: .\udo\tests\ParserUnitTest.java
	 */

package udo.tests;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Calendar;

import org.junit.Test;

import udo.main.Parser;
import udo.util.shared.Command;
import udo.util.shared.Constants.Keys;
import udo.util.shared.EditField;
import udo.util.shared.InputData;
import udo.util.shared.ListQuery;
import udo.util.shared.ParsingStatus;

public class ParserUnitTest {

	Parser p = new Parser();
	Calendar cal = Calendar.getInstance();
	
	@Test
	public void testSearchAction() {
		String search = "search jo ba b";
		InputData data = p.getInputData(search);
		ParsingStatus status = data.getStatus();
		
		assertEquals(ParsingStatus.SUCCESS, status);
		
		search = "search s";
		data = p.getInputData(search);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.SUCCESS, status);
		
		search = "search ";
		data = p.getInputData(search);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
	}
	
	@Test
	public void testListPlan() {
		String listPlan = "list plan";
		InputData data = p.getInputData(listPlan);
		ParsingStatus status = data.getStatus();
		ListQuery type = (ListQuery) data.get(Keys.QUERY_TYPE);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.LIST, data.getCommand());
		assertEquals(ListQuery.PLAN, type);
		
		listPlan = "listPlan";
		data = p.getInputData(listPlan);
		status = data.getStatus();
		type = (ListQuery) data.get(Keys.QUERY_TYPE);
		
		assertEquals(ParsingStatus.FAIL, status);
		assertEquals(Command.NULL, data.getCommand());
	}
	
	@Test
	public void testListTask() {
		String listTask = "list task";
		InputData data = p.getInputData(listTask);
		ParsingStatus status = data.getStatus();
		ListQuery type = (ListQuery) data.get(Keys.QUERY_TYPE);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.LIST, data.getCommand());
		assertEquals(ListQuery.TASK, type);
		
		listTask = "listTask";
		data = p.getInputData(listTask);
		status = data.getStatus();
		type = (ListQuery) data.get(Keys.QUERY_TYPE);
		
		assertEquals(ParsingStatus.FAIL, status);
		assertEquals(Command.NULL, data.getCommand());
		
	}
	
	@Test
	public void testListEvent() {
		String listEvents = "list Events";
		InputData data = p.getInputData(listEvents);
		ParsingStatus status = data.getStatus();
		ListQuery type = (ListQuery) data.get(Keys.QUERY_TYPE);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.LIST, data.getCommand());
		assertEquals(ListQuery.EVENT, type);
		
		String listEvents1 = "listevents";
		InputData data1 = p.getInputData(listEvents1);
		ParsingStatus status1 = data1.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status1);
		assertEquals(Command.NULL, data1.getCommand());
	}
	
	@Test
	public void testListHashtag() {
		String listTag = "list #lala";
		InputData data = p.getInputData(listTag);
		ParsingStatus status = data.getStatus();
		ListQuery type = (ListQuery) data.get(Keys.QUERY_TYPE);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.LIST, data.getCommand());
		assertEquals(ListQuery.SINGLE_HASHTAG, type);
		
		listTag = "list #";
		data = p.getInputData(listTag);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
	}
	
	@Test
	public void testListDate() {
		String listDate = "list 20/1";
		InputData data = p.getInputData(listDate);
		ParsingStatus status = data.getStatus();
		ListQuery type = (ListQuery) data.get(Keys.QUERY_TYPE);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.LIST, data.getCommand());
		assertEquals(ListQuery.DATE, type);
		
		// boundary case of negative date
		listDate = "list -20/1";
		data = p.getInputData(listDate);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		// boundary case of typo date
		listDate = "list 20/1/";
		data = p.getInputData(listDate);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		// boundary case of days
		listDate = "list today";
		data = p.getInputData(listDate);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.SUCCESS, status);
		
		//boundary case of no "day" behind
		listDate = "list tomorrow";
		data = p.getInputData(listDate);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.SUCCESS, status);
	}
	
	@Test
	public void testListAll() {
		String listAll = "list ALL";
		InputData data = p.getInputData(listAll);
		ParsingStatus status = data.getStatus();
		ListQuery type = (ListQuery) data.get(Keys.QUERY_TYPE);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.LIST, data.getCommand());
		assertEquals(ListQuery.ALL, type);
		
		listAll = "list";
		data = p.getInputData(listAll);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
	}
	
	@Test
	public void testListDone() {
		String listDone = "list done";
		InputData data = p.getInputData(listDone);
		ParsingStatus status = data.getStatus();
		ListQuery type = (ListQuery) data.get(Keys.QUERY_TYPE);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.LIST, data.getCommand());
		assertEquals(ListQuery.DONE, type);
		
		listDone = "list DoNe";
		data = p.getInputData(listDone);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.SUCCESS, status);
		
		listDone = "list Do";
		data = p.getInputData(listDone);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
	}
	
	@Test
	public void testAddPlan() {
		String plan1 = "add finish #cs2103 stuff 9/2";
		InputData data = p.getInputData(plan1);
		ParsingStatus status = data.getStatus();
		Object title = data.get(Keys.TITLE);
		Object hashtags = data.get(Keys.HASHTAGS);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.ADD_PLAN, data.getCommand());
		assertEquals("finish cs2103 stuff 9/2", title);
		assertEquals("[cs2103]", hashtags.toString());
		
		// boundary case of unfilled fields
		plan1 = "add ";
		data = p.getInputData(plan1);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		// boundary case of blank title
		plan1 = "add     ";
		data = p.getInputData(plan1);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
	}
	
	@Test
	public void testAddTask() {
		// boundary case of hashtag keyword
		String task1 = "add Meet jane after #school #by saturday 7:55pm";
		InputData data = p.getInputData(task1);
		ParsingStatus status = data.getStatus();
		Object title = data.get(Keys.TITLE);
		Object hashtags = data.get(Keys.HASHTAGS);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.ADD_TASK, data.getCommand());
		assertEquals("Meet jane after school", title);
		assertEquals("[school, by]", hashtags.toString());
		
		Calendar due = (Calendar) data.get(Keys.DUE);
		int day = due.get(Calendar.DAY_OF_MONTH);
		int month = due.get(Calendar.MONTH);
		int year = due.get(Calendar.YEAR);
		int hour = due.get(Calendar.HOUR);
		int mins = due.get(Calendar.MINUTE);
		
		// This test case requires one to change the date
		// commented out to next Saturday's date
		// assertEquals(8, day);
		// assertEquals(10, month);
		// assertEquals(2014, year);
		assertEquals(7, hour);
		assertEquals(55, mins);
		
		// test for no time input
		task1 = "add Meet jane after #school #by tomorrow";
		data = p.getInputData(task1);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		// test for no date input
		task1 = "add Meet jane after #school #by 7am";
		data = p.getInputData(task1);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		// test with 2 days in input
		task1 = "add buy sunday times by sunday 12am";
		data = p.getInputData(task1);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.SUCCESS, status);
	}
	
	@Test
	public void testAddEvent() {
		// boundary case of different date and time formats
		String event = "add meet #boss from 13/2/2013 10:10am to 22/1 9pm #vacation";
		InputData data = p.getInputData(event);
		ParsingStatus status = data.getStatus();
		Object title = data.get(Keys.TITLE);
		Object hashtags = data.get(Keys.HASHTAGS);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.ADD_EVENT, data.getCommand());
		assertEquals("meet boss", title);
		assertEquals("[boss, vacation]", hashtags.toString());
		
		Calendar startEvent = (Calendar) data.get(Keys.START);
		Calendar endEvent = (Calendar) data.get(Keys.END);
		
		int startDay = startEvent.get(Calendar.DAY_OF_MONTH);
		int startMonth = startEvent.get(Calendar.MONTH);
		int startYear = startEvent.get(Calendar.YEAR);
		int startHour = startEvent.get(Calendar.HOUR);
		int startMins = startEvent.get(Calendar.MINUTE);
		
		assertEquals(13, startDay);
		assertEquals(1, startMonth);
		assertEquals(2013, startYear);
		assertEquals(10, startHour);
		assertEquals(10, startMins);
		
		int endDay = endEvent.get(Calendar.DAY_OF_MONTH);
		int endMonth = endEvent.get(Calendar.MONTH);
		int endYear = endEvent.get(Calendar.YEAR);
		int endHour = endEvent.get(Calendar.HOUR);
		int endMins = endEvent.get(Calendar.MINUTE);
		
		assertEquals(22, endDay);
		assertEquals(0, endMonth);
		assertEquals(2014, endYear);
		assertEquals(9, endHour);
		assertEquals(0, endMins);
		
		// boundary case of empty title
		event = "add from 12/12 10am to 12pm";
		data = p.getInputData(event);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		// boundary case of 1 empty field
		event = "add from 10am to 12pm";
		data = p.getInputData(event);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		event = "add from 12/12 to 12pm";
		data = p.getInputData(event);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		event = "add from 12/12 10am to ";
		data = p.getInputData(event);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		// case of days
		event = "add meet #boss from tomorrow 10am to 9:12am";
		data = p.getInputData(event);
		status = data.getStatus();
				
		assertEquals(ParsingStatus.SUCCESS, status);
		
		startEvent = (Calendar) data.get(Keys.START);
		endEvent = (Calendar) data.get(Keys.END);
		
		startDay = startEvent.get(Calendar.DAY_OF_MONTH);
		startMonth = startEvent.get(Calendar.MONTH);
		startYear = startEvent.get(Calendar.YEAR);
		startHour = startEvent.get(Calendar.HOUR);
		startMins = startEvent.get(Calendar.MINUTE);
		
		assertEquals(cal.get(Calendar.DAY_OF_MONTH) + 1, startDay);
		assertEquals(cal.get(Calendar.MONTH), startMonth);
		assertEquals(cal.get(Calendar.YEAR), startYear);
		assertEquals(10, startHour);
		assertEquals(0, startMins);
		
		endDay = endEvent.get(Calendar.DAY_OF_MONTH);
		endMonth = endEvent.get(Calendar.MONTH);
		endYear = endEvent.get(Calendar.YEAR);
		endHour = endEvent.get(Calendar.HOUR);
		endMins = endEvent.get(Calendar.MINUTE);
		
		assertEquals(cal.get(Calendar.DAY_OF_MONTH) + 1, endDay);
		assertEquals(cal.get(Calendar.MONTH), endMonth);
		assertEquals(cal.get(Calendar.YEAR), endYear);
		assertEquals(9, endHour);
		assertEquals(12, endMins);
		
		// case of 1 day event
		event = "add meet #boss from 12/12/12 10am to 9:12am";
		data = p.getInputData(event);
		status = data.getStatus();
		title = data.get(Keys.TITLE);
		hashtags = data.get(Keys.HASHTAGS);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.ADD_EVENT, data.getCommand());
		assertEquals("meet boss", title);
		assertEquals("[boss]", hashtags.toString());
		
		startEvent = (Calendar) data.get(Keys.START);
		endEvent = (Calendar) data.get(Keys.END);
		
		startDay = startEvent.get(Calendar.DAY_OF_MONTH);
		startMonth = startEvent.get(Calendar.MONTH);
		startYear = startEvent.get(Calendar.YEAR);
		startHour = startEvent.get(Calendar.HOUR);
		startMins = startEvent.get(Calendar.MINUTE);
		
		assertEquals(12, startDay);
		assertEquals(11, startMonth);
		assertEquals(2012, startYear);
		assertEquals(10, startHour);
		assertEquals(0, startMins);
		
		endDay = endEvent.get(Calendar.DAY_OF_MONTH);
		endMonth = endEvent.get(Calendar.MONTH);
		endYear = endEvent.get(Calendar.YEAR);
		endHour = endEvent.get(Calendar.HOUR);
		endMins = endEvent.get(Calendar.MINUTE);
		
		assertEquals(12, endDay);
		assertEquals(11, endMonth);
		assertEquals(2012, endYear);
		assertEquals(9, endHour);
		assertEquals(12, endMins);
	}

	@Test
	public void testDelete() {
		
		String delete1 = "delete 12359";
		InputData data1 = p.getInputData(delete1);
		ParsingStatus status1 = data1.getStatus();
		Command type1 = data1.getCommand(); 
		int uid1 = (int) data1.get(Keys.UID);
		
		assertEquals(ParsingStatus.SUCCESS, status1);
		assertEquals(Command.DELETE, type1);
		assertEquals(12359, uid1);
		
		String delete3 = "delete -0000";
		InputData data3 = p.getInputData(delete3);
		ParsingStatus status3 = data3.getStatus();
		Command type3 = data3.getCommand(); 
		int uid3 = (int) data3.get(Keys.UID);
		
		assertEquals(ParsingStatus.SUCCESS, status3);
		assertEquals(Command.DELETE, type3);
		assertEquals(0, uid3);
		
		// Testing boundary for string
		String delete4 = "delete delet";
		InputData data4 = p.getInputData(delete4);
		ParsingStatus status4 = data4.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status4);
	}

	@Test
	public void testMarkDone() {
		// testing within acceptance region
		String done = "done 12359";
		InputData data = p.getInputData(done);
		ParsingStatus status = data.getStatus();
		Command type = data.getCommand(); 
		int uid = (int) data.get(Keys.UID);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.MARK_DONE, type);
		assertEquals(12359, uid);
		
		// Testing outside boundary case
		done = "done -0";
		data = p.getInputData(done);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.SUCCESS, status);
	
		// Testing boundary for string
		done = "done insta";
		data = p.getInputData(done);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		done = "done ";
		data = p.getInputData(done);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		done = "done";
		data = p.getInputData(done);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
	}

	@Test
	public void testToggleDone() {
		// testing within acceptance region
		String toggleDone = "toggle done 12359 ";
		InputData data = p.getInputData(toggleDone);
		ParsingStatus status = data.getStatus();
		Command type = data.getCommand(); 
		int uid = (int) data.get(Keys.UID);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.TOGGLE_DONE, type);
		assertEquals(12359, uid);
		
		// testing typo command
		toggleDone = "toggledone 12359 ";
		data = p.getInputData(toggleDone);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		toggleDone = "toggle done -00000";
		data = p.getInputData(toggleDone);
		status = data.getStatus();
		uid = (int) data.get(Keys.UID);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(00000, uid);
		
		toggleDone = "toggle done ";
		data = p.getInputData(toggleDone);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		// Testing boundary for string
		toggleDone = "toggle done ios";
		data = p.getInputData(toggleDone);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
	}

	@Test
	public void testEditDueDate() {
		// testing date boundary of dd/mm
		String editDueDate = "edit 0 due date 1/12";
		InputData data = p.getInputData(editDueDate);
		ParsingStatus status = data.getStatus();
		Command type = data.getCommand();
		EditField field = (EditField) data.get(Keys.FIELD);
		Calendar date = (Calendar) data.get(Keys.VALUE);
		
		int day = date.get(Calendar.DAY_OF_MONTH);
		int month = date.get(Calendar.MONTH);
		int year = date.get(Calendar.YEAR);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.DUE_DATE, field);
		
		assertEquals(1, day);
		assertEquals(11, month);
		assertEquals(2014, year);
		
		// testing date boundary of dd/mm/yy
		editDueDate = "edit 0430 due date 9/9/11";
		data = p.getInputData(editDueDate);
		status = data.getStatus();
		type = data.getCommand();
		field = (EditField) data.get(Keys.FIELD);
		date = (Calendar) data.get(Keys.VALUE);
		
		day = date.get(Calendar.DAY_OF_MONTH);
		month = date.get(Calendar.MONTH);
		year = date.get(Calendar.YEAR);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.DUE_DATE, field);
		
		assertEquals(9, day);
		assertEquals(8, month);
		assertEquals(2011, year);
		
		// testing date boundary of dd/mm/yyyy
		editDueDate = "edit 20430 due date 28/2/1111";
		data = p.getInputData(editDueDate);
		status = data.getStatus();
		type = data.getCommand();
		field = (EditField) data.get(Keys.FIELD);
		date = (Calendar) data.get(Keys.VALUE);
		
		day = date.get(Calendar.DAY_OF_MONTH);
		month = date.get(Calendar.MONTH);
		year = date.get(Calendar.YEAR);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.DUE_DATE, field);
		
		assertEquals(28, day);
		assertEquals(1, month);
		assertEquals(1111, year);
		
		// testing typo command
		editDueDate = "edit 0 due";
		data = p.getInputData(editDueDate);
		status = data.getStatus();
		assertEquals(ParsingStatus.FAIL, status);
		
	}

	@Test
	public void testEditDueTime() {
		// testing within boundary of time hh:mma
		String editDueTime = "edit 30953 due time 12:10am";
		InputData data = p.getInputData(editDueTime);
		ParsingStatus status = data.getStatus();
		Command type = data.getCommand();
		EditField field = (EditField) data.get(Keys.FIELD);
		Calendar date = (Calendar) data.get(Keys.VALUE);
		
		int hour = date.get(Calendar.HOUR);
		int mins = date.get(Calendar.MINUTE);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.DUE_TIME, field);
	
		assertEquals(0, hour);
		assertEquals(10, mins);
		
		// testing within boundary of time hh:mma
		editDueTime = "edit 30953 due time 12am";
		data = p.getInputData(editDueTime);
		status = data.getStatus();
		type = data.getCommand();
		field = (EditField) data.get(Keys.FIELD);
		date = (Calendar) data.get(Keys.VALUE);
		
		hour = date.get(Calendar.HOUR);
		mins = date.get(Calendar.MINUTE);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.DUE_TIME, field);
	
		assertEquals(0, hour);
		assertEquals(0, mins);
		
		// testing typo command
		editDueTime = "edit 30953 due 12am";
		data = p.getInputData(editDueTime);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		// testing negative time
		editDueTime = "edit 30953 duetime -10am";
		data = p.getInputData(editDueTime);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
	}

	@Test
	public void testEditEndDate() {
		// testing date boundary of dd/mm
		String editEndDate = "edit 23859 end date 1/1";
		InputData data = p.getInputData(editEndDate);
		ParsingStatus status = data.getStatus();
		Command type = data.getCommand();
		EditField field = (EditField) data.get(Keys.FIELD);
		Calendar date = (Calendar) data.get(Keys.VALUE);
		
		int day = date.get(Calendar.DAY_OF_MONTH);
		int month = date.get(Calendar.MONTH);
		int year = date.get(Calendar.YEAR);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.END_DATE, field);
		
		assertEquals(1, day);
		assertEquals(0, month);
		assertEquals(2014, year);
		
		// testing date boundary of dd/mm/yy
		editEndDate = "edit 23859 end date 1/1/34";
		data = p.getInputData(editEndDate);
		status = data.getStatus();
		type = data.getCommand();
		field = (EditField) data.get(Keys.FIELD);
		date = (Calendar) data.get(Keys.VALUE);
		
		day = date.get(Calendar.DAY_OF_MONTH);
		month = date.get(Calendar.MONTH);
		year = date.get(Calendar.YEAR);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.END_DATE, field);
		
		assertEquals(1, day);
		assertEquals(0, month);
		assertEquals(2034, year);
		
		// testing date boundary of dd/mm/yy
		editEndDate = "edit 23859 end date 1/1/3423";
		data = p.getInputData(editEndDate);
		status = data.getStatus();
		type = data.getCommand();
		field = (EditField) data.get(Keys.FIELD);
		date = (Calendar) data.get(Keys.VALUE);
		
		day = date.get(Calendar.DAY_OF_MONTH);
		month = date.get(Calendar.MONTH);
		year = date.get(Calendar.YEAR);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.END_DATE, field);
		
		assertEquals(1, day);
		assertEquals(0, month);
		assertEquals(3423, year);
		
		// test typo
		editEndDate = "edit 23859 enddate 1/1/3423";
		data = p.getInputData(editEndDate);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
	}

	@Test
	public void testEditEndTime() {
		// testing date boundary of time for hh:mma
		String editEndTime = "edit 23535 end time 10:12pm";
		InputData data = p.getInputData(editEndTime);
		ParsingStatus status = data.getStatus();
		Command type = data.getCommand();
		EditField field = (EditField) data.get(Keys.FIELD);
		Calendar date = (Calendar) data.get(Keys.VALUE);
		
		int hour = date.get(Calendar.HOUR);
		int mins = date.get(Calendar.MINUTE);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.END_TIME, field);
	
		assertEquals(10, hour);
		assertEquals(12, mins);
		
		// testing date boundary of time for hha
		editEndTime = "edit 23535 end time 10pm";
		data = p.getInputData(editEndTime);
		status = data.getStatus();
		type = data.getCommand();
		field = (EditField) data.get(Keys.FIELD);
		date = (Calendar) data.get(Keys.VALUE);
		
		hour = date.get(Calendar.HOUR);
		mins = date.get(Calendar.MINUTE);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.END_TIME, field);
	
		assertEquals(10, hour);
		assertEquals(0, mins);
		
		// test typo
		editEndTime = "edit 23535 endtime 10pm";
		data = p.getInputData(editEndTime);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
	
	}

	@Test
	public void testEditStartTime() {
		String editStartTime = "edit 23834 start time 9:00am";
		InputData data = p.getInputData(editStartTime);
		ParsingStatus status = data.getStatus();
		Command type = data.getCommand();
		EditField field = (EditField) data.get(Keys.FIELD);
		Calendar date = (Calendar) data.get(Keys.VALUE);
		
		int hour = date.get(Calendar.HOUR);
		int mins = date.get(Calendar.MINUTE);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.START_TIME, field);
	
		assertEquals(9, hour);
		assertEquals(0, mins);
		
		// boundary case of negative time
		editStartTime = "edit 23834 start time -2pm";
		data = p.getInputData(editStartTime);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		// boundary case of wrongly filled edit
		editStartTime = "edit 23834 start time 2opm";
		data = p.getInputData(editStartTime);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		// boundary case of unfilled edit
		editStartTime = "edit 23834 start time ";
		data = p.getInputData(editStartTime);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
	}

	@Test
	public void testEditStartDate() {
		// test case within boundary
		String editStartDate = "edit 21345 start date 9/12/13";
		InputData data = p.getInputData(editStartDate);
		ParsingStatus status = data.getStatus();
		Command type = data.getCommand();
		EditField field = (EditField) data.get(Keys.FIELD);
		Calendar date = (Calendar) data.get(Keys.VALUE);
		
		int day = date.get(Calendar.DAY_OF_MONTH);
		int month = date.get(Calendar.MONTH);
		int year = date.get(Calendar.YEAR);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.START_DATE, field);
		
		assertEquals(9, day);
		assertEquals(11, month);
		assertEquals(2013, year);
		
		// boundary case of wrongly filled edit
		editStartDate = "edit 21345 start date 9/ ";
		data = p.getInputData(editStartDate);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		// boundary case of unfilled edit
		editStartDate = "edit 21345 start date ";
		data = p.getInputData(editStartDate);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
		
		// boundary case of negative date
		editStartDate = "edit 21345 start date -19/2";
		data = p.getInputData(editStartDate);
		status = data.getStatus();
		
		assertEquals(ParsingStatus.FAIL, status);
	}

	@Test
	public void testEditTitle() {
		//within test boundary
		String editTitle = "edit 72384 title hello #everybody";
		InputData data = p.getInputData(editTitle);
		ParsingStatus status = data.getStatus();
		Command type = data.getCommand();
		EditField field = (EditField) data.get(Keys.FIELD);
		Object title = data.get(Keys.VALUE);
		ArrayList<String> tags = (ArrayList<String>) data.get(Keys.HASHTAGS);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.TITLE, field);
		assertEquals("hello everybody", title);
		assertEquals("[everybody]", tags.toString());
		
		//boundary case of unfilled hashtag
		editTitle = "edit 72384 title hello #";
		data = p.getInputData(editTitle);
		status = data.getStatus();
		type = data.getCommand();
		field = (EditField) data.get(Keys.FIELD);
		title = data.get(Keys.VALUE);
		tags = (ArrayList<String>) data.get(Keys.HASHTAGS);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.TITLE, field);
		assertEquals("hello", title);
		assertEquals("[]", tags.toString());
		
		editTitle = "edit 72384 titles hello #everybody";
		data = p.getInputData(editTitle);
		status = data.getStatus();
		type = data.getCommand();
		field = (EditField) data.get(Keys.FIELD);
		title = data.get(Keys.VALUE);
		tags = (ArrayList<String>) data.get(Keys.HASHTAGS);
		
		assertEquals(ParsingStatus.SUCCESS, status);
		assertEquals(Command.EDIT, type);
		assertEquals(EditField.TITLE, field);
		assertEquals("hello everybody", title);
		assertEquals("[everybody]", tags.toString());
		
		//boundary case of unfilled edit
		editTitle = "edit 72384 title ";
		data = p.getInputData(editTitle);
		status = data.getStatus();
		type = data.getCommand();
		field = (EditField) data.get(Keys.FIELD);
		title = data.get(Keys.VALUE);
		tags = (ArrayList<String>) data.get(Keys.HASHTAGS);
		
		assertEquals(ParsingStatus.FAIL, status);
		
	}
	
}

	// End of segment: .\udo\tests\ParserUnitTest.java





	/**
	 * origin: .\udo\util\parser\Action.java
	 */

package udo.util.parser;

import udo.language.LanguagePack;
import udo.util.shared.Command;
import udo.util.shared.InputData;

public interface Action {
	public final LanguagePack mLang = LanguagePack.getInstance();
	public InputData run(Command type, String input);
	public InputData run(Command type);
}

	// End of segment: .\udo\util\parser\Action.java





	/**
	 * origin: .\udo\util\parser\add\AddActionEvent.java
	 */

package udo.util.parser.add;

import java.util.ArrayList;
import java.util.Calendar;

import udo.util.parser.DateGetter;
import udo.util.parser.TimeGetter;
import udo.util.shared.Constants.Keys;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class AddActionEvent implements AddActionType {
	
	/**
	 * This class handles the raw input for add event. It fills up the InputData
	 * passed to it.
	 */

	public AddActionEvent() {
		
	}

	@Override
	public void fill(String details, InputData data) {
		String title = getTitle(details);
		ArrayList<String> tags = getTags(details);
		Calendar start = setFirstTimeAndDate(details);
		Calendar end = setSecondTimeAndDate(details);
		if (title != null && start != null && end != null) {
			data.put(Keys.TITLE, title);
			data.put(Keys.HASHTAGS, tags);
			data.put(Keys.START, start);
			data.put(Keys.END, end);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		} else {
			data.setParsingStatus(ParsingStatus.FAIL);
		}
	}

	@Override
	public String getTitle(String input) {
		String title = input.replaceAll("#", "");
		String parts[] = title.split(" ");
		String newTitle = "";
		for (int i = 1; i < parts.length; i++) {
			if (parts[i].equals(mLang.getFROM())) {
				break;
			}
			newTitle = newTitle + parts[i] + " "; 
		}
		if (newTitle.length() != 0) {
			newTitle = newTitle.trim();
			return newTitle;
		} else {
			return null;
		}
	}

	@Override
	public ArrayList<String> getTags(String input) {
		ArrayList<String> tagArrayList = new ArrayList<String>();
		String tag;
		boolean hashTagFilled;
		String words[] = input.split(" ");
		for (String word : words) {
			hashTagFilled = word.length() > 1;
			if (word.startsWith("#") && hashTagFilled) {
				tag = word.replaceFirst("#", "");
				tagArrayList.add(tag);
			}
		}
		return tagArrayList;
	}
	
	public Calendar getDate(String input) {
		DateGetter date = new DateGetter();
		return date.getDate(input);
	}
	
	public Calendar getTime(String input) {
		TimeGetter time = new TimeGetter();
		return time.getTime(input);
	}
	
	public Calendar setFirstTimeAndDate(String details) {
		Calendar start = getTime(details);
		Calendar date = getDate(details);
		if (start != null && date != null) {
			start.set(Calendar.DAY_OF_MONTH, date.get(Calendar.DAY_OF_MONTH));
			start.set(Calendar.MONTH, date.get(Calendar.MONTH));
			start.set(Calendar.YEAR, date.get(Calendar.YEAR));
			return start;
		}
		return null;
	}
	
	public Calendar setSecondTimeAndDate(String details) {
		int toStringIndex = details.lastIndexOf(mLang.getTO());
		String endingTimeDateString = details.substring(toStringIndex);
		Calendar end = getTime(endingTimeDateString);
		Calendar date = getDate(endingTimeDateString);
		if (end != null && date != null) {
			end.set(Calendar.DAY_OF_MONTH, date.get(Calendar.DAY_OF_MONTH));
			end.set(Calendar.MONTH, date.get(Calendar.MONTH));
			end.set(Calendar.YEAR, date.get(Calendar.YEAR));
			return end;
		} else if (end != null) {
			date = getDate(details);
			if (date != null) {
				end.set(Calendar.DAY_OF_MONTH, date.get(Calendar.DAY_OF_MONTH));
				end.set(Calendar.MONTH, date.get(Calendar.MONTH));
				end.set(Calendar.YEAR, date.get(Calendar.YEAR));
				return end;
			} else {
				return null;
			}
		} else {
			return null;
		}
	}

}

	// End of segment: .\udo\util\parser\add\AddActionEvent.java





	/**
	 * origin: .\udo\util\parser\add\AddActionPlan.java
	 */

package udo.util.parser.add;

import java.util.ArrayList;

import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;
import udo.util.shared.Constants.Keys;

public class AddActionPlan implements AddActionType {

	/**
	 * This class handles all Plans. It fills in the InputData passed to it.
	 */
	
	public AddActionPlan() {
		
	}

	@Override
	public void fill(String details, InputData data) {
		String title = getTitle(details);
		ArrayList<String> tags = getTags(details);
		if (title != null) {
			data.put(Keys.TITLE, title);
			data.put(Keys.HASHTAGS, tags);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		} else {
			data.setParsingStatus(ParsingStatus.FAIL);
		}
	}

	@Override
	public String getTitle(String input) {
		String title = input.replaceAll("#", "");
		String parts[] = title.split(" ");
		String newTitle = "";
		for (int i = 1; i < parts.length; i++) {
			newTitle = newTitle + parts[i] + " "; 
		}
		if (newTitle.length() != 0) {
			newTitle = newTitle.trim();
			return newTitle;
		} else {
			return null;
		}
	}

	@Override
	public ArrayList<String> getTags(String input) {
		ArrayList<String> tagArrayList = new ArrayList<String>();
		String tag;
		String words[] = input.split(" ");
		for (String word : words) {
			if (word.startsWith("#")) {
				tag = word.replaceFirst("#", "");
				assert(!tag.isEmpty());
				tagArrayList.add(tag);
			}
		}
		return tagArrayList;
	}

}

	// End of segment: .\udo\util\parser\add\AddActionPlan.java





	/**
	 * origin: .\udo\util\parser\add\AddActionTask.java
	 */

package udo.util.parser.add;

import java.util.ArrayList;
import java.util.Calendar;

import udo.util.parser.DateGetter;
import udo.util.parser.TimeGetter;
import udo.util.shared.Constants.Keys;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class AddActionTask implements AddActionType {

	/**
	 * This class handles all Tasks. It fills in the InputData passed to it.
	 */
	
	public AddActionTask() {
		
	}

	@Override
	public void fill(String details, InputData data) {
		String title = getTitle(details);
		ArrayList<String> tags = getTags(details);
		Calendar end = setFirstTimeAndDate(details);
		if (title != null && end != null) {
			data.put(Keys.TITLE, title);
			data.put(Keys.HASHTAGS, tags);
			data.put(Keys.DUE, end);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		} else {
			data.setParsingStatus(ParsingStatus.FAIL);
		}	
	}

	@Override
	public String getTitle(String input) {
		String title = input.replaceAll("#", "");
		String parts[] = title.split(" ");
		String newTitle = "";
		for (int i = 1; i < parts.length; i++) {
			if (parts[i].equals(mLang.getBY())) {
				break;
			}
			newTitle = newTitle + parts[i] + " "; 
		}
		if (newTitle.length() != 0) {
			newTitle = newTitle.trim();
			return newTitle;
		} else {
			return null;
		}
	}

	@Override
	public ArrayList<String> getTags(String input) {
		ArrayList<String> tagArrayList = new ArrayList<String>();
		String tag;
		boolean hashTagFilled;
		String words[] = input.split(" ");
		for (String word : words) {
			hashTagFilled = word.length() > 1;
			if (word.startsWith("#") && hashTagFilled) {
				tag = word.replaceFirst("#", "");
				tagArrayList.add(tag);
			}
		}
		return tagArrayList;
	}
	
	public Calendar getDate(String input) {
		DateGetter date = new DateGetter();
		return date.getDate(input);
	}
	
	public Calendar getTime(String input) {
		TimeGetter time = new TimeGetter();
		return time.getTime(input);
	}
	
	public Calendar setFirstTimeAndDate(String details) {
		Calendar start = getTime(details);
		Calendar date = getDate(details);
		if (start != null && date != null) {
			start.set(Calendar.DAY_OF_MONTH, date.get(Calendar.DAY_OF_MONTH));
			start.set(Calendar.MONTH, date.get(Calendar.MONTH));
			start.set(Calendar.YEAR, date.get(Calendar.YEAR));
			return start;
		} else {
			return null;
		}
	}

}

	// End of segment: .\udo\util\parser\add\AddActionTask.java





	/**
	 * origin: .\udo\util\parser\add\AddActionType.java
	 */

package udo.util.parser.add;

import java.util.ArrayList;

import udo.language.LanguagePack;
import udo.util.shared.InputData;

public interface AddActionType {
	public final LanguagePack mLang = LanguagePack.getInstance();
	public void fill(String details, InputData data);
	public String getTitle(String input);
	public ArrayList<String> getTags(String input);
	
}

	// End of segment: .\udo\util\parser\add\AddActionType.java





	/**
	 * origin: .\udo\util\parser\AddAction.java
	 */

package udo.util.parser;

import udo.util.parser.add.AddActionEvent;
import udo.util.parser.add.AddActionPlan;
import udo.util.parser.add.AddActionTask;
import udo.util.parser.add.AddActionType;
import udo.util.shared.Command;
import udo.util.shared.InputData;


/** 
 * This class takes in ADD commands and break them into the following:
 * ADD_EVENT, ADD_TASK, ADD_PLAN
 * <p>
 * ADD_EVENT command is for events. Events contain a starting time and an ending time.
 * ADD_TASK command is for tasks. Tasks contain 1 deadline.
 * ADD_PLAN command is for plans. Plans have no deadlines nor starting and ending time.
 * <p>
 * Input recieve by this class is in the format: 
 * "add <<title>> from <<date>> <<time>> to <<date>> <<time>>"
 * "add <<title>> from <<date>> <<time>> to <<time>>"
 * "add <<title>> by <<date>> <<time>>"
 * "add <<title>>"
 */

public class AddAction implements Action {
	
	
	/**
	 * This method takes in user input and returns an InputData of the following 
	 * CommandType: ADD_EVENT, ADD_TASK, ADD_PLAN
	 * and the stores them in the necessary fields.
	 * 
	 * @param type
	 * @param details
	 * @return an InputData
	 */
	@Override
	public InputData run(Command type, String details) {
		InputData data;
		if (isEvent(details)) {
			data = new InputData(Command.ADD_EVENT);
			AddActionType event = new AddActionEvent();
			event.fill(details, data);
		} else if (isTask(details)) {
			data = new InputData(Command.ADD_TASK);
			AddActionType task = new AddActionTask();
			task.fill(details, data);
		} else {
			data = new InputData(Command.ADD_PLAN);
			AddActionType plan = new AddActionPlan();
			plan.fill(details, data);
		} 
		return data;
	}

	@Override
	public InputData run(Command type) {
		return null;
	}

	private boolean isEvent(String details) {
		String task = details.toLowerCase();
		task = task.replaceAll("#", "");
		String parts[] = task.split(" ");
		boolean containsKeywordFrom = false;
		boolean containsKeywordTo = false;
		for (int i = 0; i < parts.length; i++) {
			if (parts[i].equals(mLang.getFROM())) {
				containsKeywordFrom = true;
			}
			if (parts[i].equals(mLang.getTO())) {
				containsKeywordTo = true;
			}
		}
		if (containsKeywordFrom && containsKeywordTo) {
			return true;
		} else {
			return false;
		}
	}

	private boolean isTask(String details) {
		String task = details.toLowerCase();
		task = task.replaceAll("#", "");
		String parts[] = task.split(" ");
		boolean containsKeywordBy = false;
		for (int i = 0; i < parts.length; i++) {
			if (parts[i].equals(mLang.getBY())) {
				containsKeywordBy = true;
			}
		}
		if (containsKeywordBy) {
			return true;
		} else {
			return false;
		}
	}

}

	// End of segment: .\udo\util\parser\AddAction.java





	/**
	 * origin: .\udo\util\parser\DateGetter.java
	 */

package udo.util.parser;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

import udo.language.LanguagePack;

public class DateGetter {
	
	/**
	 * This class returns a calendar object set to the first date it reads from 
	 * the input. It takes in days and returns a date. 
	 * Dates from days will be set a week from the current date.
	 * It takes in date of format dd/MM, dd/MM/yy and dd/MM/yyyy
	 */

	private LanguagePack mLang = LanguagePack.getInstance();
	
	private static Calendar mDate = null;
	private String mDateFormat[] = {"dd/MM", "dd/MM/yy", "dd/MM/yyyy", ""};
	private String mDays[] = {
			mLang.getTODAY(), 
			mLang.getSUNDAY(), 
			mLang.getMONDAY(), 
			mLang.getTUESDAY(),					
			mLang.getWEDNESDAY(), 
			mLang.getTHURSDAY(), 
			mLang.getFRIDAY(), 
			mLang.getSATURDAY(), 
			mLang.getTOMORROW()};
	
	public DateGetter() {
		
	}
	
	/**
	 * Method returns the first date it reads from input.
	 * Detects date by "/" character
	 * Dates cannot contain spaces in-between
	 * Days will be set a week from the the current date
	 * 
	 * @param input string
	 * @return Calendar date object
	 */
	public Calendar getDate(String input) {
		decipherText(input);
		return mDate;
	}
	
	// facilitates how all instructions are run
	private void decipherText(String input) {
		int dateFormat = getDateFormat(input);
		if (dateFormat == -1) { 		// if date format does not exist, it is a day format
			int day = getDay(input);
			mDate = formatDaySubstring(day);
		} else if (dateFormat != 3) {	// if date format is not "", it is one of the formats provided
			String dateString = getDateString(input, dateFormat);
			mDate = formatDateSubstring(dateString, dateFormat);
		} else {
			mDate = null;
		}
	}

	private int getDateFormat(String input) {
		if (input.contains("/")) {
			int dayMonthSlashIndex = input.indexOf("/");
			int offset = dayMonthSlashIndex + 1; 	// gets the second "/" from "dd/mm/yy" 
			int monthYearSlashIndex = input.indexOf("/", offset); 
	
			if (monthYearSlashIndex == -1 ||
				!containsYear(dayMonthSlashIndex, monthYearSlashIndex)) { // dd/MM format
				return 0;
			} else if (containsYear(dayMonthSlashIndex, monthYearSlashIndex) &&
						!hasFourYearDigits(monthYearSlashIndex, input)) {
				return 1;
			} else if (containsYear(dayMonthSlashIndex, monthYearSlashIndex) &&
					hasFourYearDigits(monthYearSlashIndex, input)) {
				return 2;
			} else {
				return 3;
			}
		} else {
			return -1;
		}
	}

	// checks if the first "/" and second "/" are from the same date string
	private boolean containsYear(int dayMonthSlashIndex, int monthYearSlashIndex) {
		int difference = monthYearSlashIndex - dayMonthSlashIndex;
		if (difference == 2 || difference == 3) { // xx/x/xx or xx/xx/xx (one month or 2 months)
			return true;
		} else {
			return false;
		}
	}

	private boolean hasFourYearDigits(int monthYearSlashIndex, String input) {
		String year = input;
		int yearStartIndex = monthYearSlashIndex + 1; 	// index of first year digit
		int yearEndIndex = monthYearSlashIndex + 5;		// index of last year digit
		if (yearEndIndex > year.length()) {				// takes into account substring API offset
			yearEndIndex = year.length();
		}
		int yearDigits = 0;
		String yearDigit;
		for (int i = yearStartIndex; i < yearEndIndex; i++) {
			yearDigit = year.substring(i, i + 1);
			if (isInteger(yearDigit)) {
				yearDigits++;
			}
		}
		
		if (yearDigits == 4) { 
			return true;
		} else {
			return false;
		}
	}

	private String getDateString(String input, int dateFormat) {
		switch (dateFormat) {
			case 0:
				return extractDateWithNoYears(input);
			case 1:
				return extractDateWithTwoYears(input);
			case 2:
				return extractDateWithFourYears(input);
			default:
				return null;
		}
	}

	private String extractDateWithNoYears(String input) {
		String dateString = input.toUpperCase();
		String dateStringArr[] = dateString.split(" ");
		boolean isOfValidLength;
		String dayFirstDigit;
		String monthLastDigit;
		int monthLastDigitIndex;
		for (int i = 0; i < dateStringArr.length; i++) {
			isOfValidLength = (dateStringArr[i].length() >= 3 && dateStringArr[i].length() <= 5); // d/m to dd/mm
			dayFirstDigit = dateStringArr[i].substring(0, 1);
			monthLastDigitIndex = dateStringArr[i].length() - 1;
			monthLastDigit = dateStringArr[i].substring(monthLastDigitIndex);
			if (dateStringArr[i].contains("/") &&
				isOfValidLength &&
				isInteger(dayFirstDigit) &&
				isInteger(monthLastDigit)) { 
				return dateStringArr[i];
			}
		}
		return null;
	}

	private String extractDateWithTwoYears(String input) {
		String dateString = input.toUpperCase();
		String dateStringArr[] = dateString.split(" ");
		boolean isOfValidLength;
		String dayFirstDigit;
		String yearLastDigit;
		int yearLastDigitIndex;
		for (int i = 0; i < dateStringArr.length; i++) {
			isOfValidLength = (dateStringArr[i].length() >= 6 && dateStringArr[i].length() <=8); // d/m/yy to dd/mm/yy
			dayFirstDigit = dateStringArr[i].substring(0, 1);
			yearLastDigitIndex = dateStringArr[i].length() - 1;
			yearLastDigit = dateStringArr[i].substring(yearLastDigitIndex);
			if (dateStringArr[i].contains("/") &&
				isOfValidLength &&
				isInteger(dayFirstDigit) &&
				isInteger(yearLastDigit)) { 
				return dateStringArr[i];
			}
		}
		return null;
	}

	private String extractDateWithFourYears(String input) {
		String dateString = input.toUpperCase();
		String dateStringArr[] = dateString.split(" ");
		boolean isOfValidLength;
		String dayFirstDigit;
		String yearLastDigit;
		int yearLastDigitIndex;
		for (int i = 0; i < dateStringArr.length; i++) {
			isOfValidLength = (dateStringArr[i].length() >= 8 && dateStringArr[i].length() <=10); // d/m/yyyy to dd/mm/yyyy
			dayFirstDigit = dateStringArr[i].substring(0, 1);
			yearLastDigitIndex = dateStringArr[i].length() - 1;
			yearLastDigit = dateStringArr[i].substring(yearLastDigitIndex);
			if (dateStringArr[i].contains("/") &&
				isOfValidLength &&
				isInteger(dayFirstDigit) &&
				isInteger(yearLastDigit)) { 
				return dateStringArr[i];
			}
		}
		return null;
	}

	private Calendar formatDateSubstring(String input, int dateFormat) {
		Calendar cal = Calendar.getInstance();
		int year = cal.get(Calendar.YEAR);
		SimpleDateFormat format = new SimpleDateFormat(mDateFormat[dateFormat]);
		Date date;
		if (input != null) {
			try {
				date = format.parse(input);
				cal.setTime(date);
				cal.set(Calendar.HOUR_OF_DAY, 23);
				cal.set(Calendar.MINUTE, 59);
				
				if (dateFormat == 0) {
					cal.set(Calendar.YEAR, year);
				}
			} catch (ParseException parserException) {
				cal = null;
				return cal;
			}
			return cal;
		} else {
			cal = null;
			return cal;
		}
	}

	private boolean isInteger(String input) {
		try {
			Integer.parseInt(input);
			return true;
		} catch (Exception e) {
			return false;
		}
	}

	private int getDay(String input) {
		String dayString = input.toLowerCase();
		for (int i = 0; i < mDays.length; i++) {
			if (dayString.contains(mDays[i])) {
				return i;
			}
		}
		return -1;
	}

	private Calendar formatDaySubstring(int day) {
		Calendar cal = Calendar.getInstance();
		int difference = getDayNextWeek(day, cal);
		if (day == 0) {
			return cal;
		} else if (day == 8) {
			cal.add(Calendar.DATE, 1);
			return cal;
		} else if (day > 0 && day < 8) {
			cal.add(Calendar.DAY_OF_MONTH, difference);
			return cal;
		} else {
			cal = null;
			return cal;
		}
	}

	private int getDayNextWeek(int day, Calendar cal) {
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK);
		int difference = day - dayOfWeek;
		if (difference < 0) {
			difference = 7 + difference;
		} else if (difference == 0) {
			difference = 7;
		}
		return difference;
	}

}

	// End of segment: .\udo\util\parser\DateGetter.java





	/**
	 * origin: .\udo\util\parser\DeleteAction.java
	 */

package udo.util.parser;

import udo.util.shared.Command;
import udo.util.shared.Constants.Keys;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class DeleteAction implements Action {
	
	/**
	 * This class reads in the uid to be deleted.
	 * Input recieved by this class is in the format: "delete <<uid>>"
	 */

	public DeleteAction() {
		
	}

	@Override
	public InputData run(Command type) {
		return null;
	}
	
	@Override
	public InputData run(Command type, String input) {
		InputData data = new InputData(type);
		int uid = extractUid(input);
		if (uid == -1) {
			data.setParsingStatus(ParsingStatus.FAIL);
		} else {
			data.put(Keys.UID, uid);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		}
		return data;
	}
	
	private boolean isInteger(String input) {
		try {
			Integer.parseInt(input);
			return true;
		} catch (Exception e) {
			return false;
		}
	}
	
	private int extractUid(String input) {
		String parts[] = input.split(" ");
		if (parts.length >= 2) {
			String uid = parts[1];
			if (isInteger(uid)) {
				int id = Integer.parseInt(uid);
				return id;
			}
		} 
		return -1;
	}
}

	// End of segment: .\udo\util\parser\DeleteAction.java





	/**
	 * origin: .\udo\util\parser\edit\EditActionDueDate.java
	 */

package udo.util.parser.edit;

import java.util.Calendar;

import udo.util.parser.DateGetter;
import udo.util.shared.Constants.Keys;
import udo.util.shared.EditField;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class EditActionDueDate implements EditActionField {

	/**
	 * This class handles the due date field
	 */
	
	public EditActionDueDate() {
		
	}

	@Override
	public void fill(String details, InputData data) {
		DateGetter date = new DateGetter();
		Calendar dueDate = date.getDate(details);
		if (dueDate != null) {
			data.put(Keys.FIELD, EditField.DUE_DATE);
			data.put(Keys.VALUE, dueDate);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		} else {
			data.setParsingStatus(ParsingStatus.FAIL);
		}
	}

}

	// End of segment: .\udo\util\parser\edit\EditActionDueDate.java





	/**
	 * origin: .\udo\util\parser\edit\EditActionDueTime.java
	 */

package udo.util.parser.edit;

import java.util.Calendar;

import udo.util.parser.TimeGetter;
import udo.util.shared.Constants.Keys;
import udo.util.shared.EditField;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class EditActionDueTime implements EditActionField {

	/**
	 * This class handles the due time field
	 */
	
	public EditActionDueTime() {
		
	}

	@Override
	public void fill(String details, InputData data) {
		TimeGetter time = new TimeGetter();
		Calendar dueTime = time.getTime(details);
		if (dueTime != null) {
			data.put(Keys.FIELD, EditField.DUE_TIME);
			data.put(Keys.VALUE, dueTime);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		} else {
			data.setParsingStatus(ParsingStatus.FAIL);
		}
	}

}

	// End of segment: .\udo\util\parser\edit\EditActionDueTime.java





	/**
	 * origin: .\udo\util\parser\edit\EditActionEndDate.java
	 */

package udo.util.parser.edit;

import java.util.Calendar;

import udo.util.parser.DateGetter;
import udo.util.shared.Constants.Keys;
import udo.util.shared.EditField;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class EditActionEndDate implements EditActionField {

	/**
	 * This class handles the end date field
	 */
	
	public EditActionEndDate() {
		
	}

	@Override
	public void fill(String details, InputData data) {
		DateGetter d = new DateGetter();
		Calendar endDate = d.getDate(details);
		if (endDate != null) {
			data.put(Keys.FIELD, EditField.END_DATE);
			data.put(Keys.VALUE, endDate);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		} else {
			data.setParsingStatus(ParsingStatus.FAIL);	
		}
	}

}

	// End of segment: .\udo\util\parser\edit\EditActionEndDate.java





	/**
	 * origin: .\udo\util\parser\edit\EditActionEndTime.java
	 */

package udo.util.parser.edit;

import java.util.Calendar;

import udo.util.parser.TimeGetter;
import udo.util.shared.Constants.Keys;
import udo.util.shared.EditField;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class EditActionEndTime implements EditActionField {

	/**
	 * This class handles the end time field
	 */
	
	public EditActionEndTime() {
		
	}

	@Override
	public void fill(String details, InputData data) {
		TimeGetter time = new TimeGetter();
		Calendar endTime = time.getTime(details);
		if (endTime != null) {
			data.put(Keys.FIELD, EditField.END_TIME);
			data.put(Keys.VALUE, endTime);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		} else {
			data.setParsingStatus(ParsingStatus.FAIL);
		}
	}

}

	// End of segment: .\udo\util\parser\edit\EditActionEndTime.java





	/**
	 * origin: .\udo\util\parser\edit\EditActionField.java
	 */

package udo.util.parser.edit;

import udo.util.shared.InputData;

public interface EditActionField {
	
	public void fill(String details, InputData data);

}

	// End of segment: .\udo\util\parser\edit\EditActionField.java





	/**
	 * origin: .\udo\util\parser\edit\EditActionStartDate.java
	 */

package udo.util.parser.edit;

import java.util.Calendar;

import udo.util.parser.DateGetter;
import udo.util.shared.Constants.Keys;
import udo.util.shared.EditField;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class EditActionStartDate implements EditActionField {

	/**
	 * This class handles the start date field
	 */
	
	public EditActionStartDate() {
		
	}

	@Override
	public void fill(String details, InputData data) {
		DateGetter d = new DateGetter();
		Calendar startDate = d.getDate(details);
		if (startDate != null) {
			data.put(Keys.FIELD, EditField.START_DATE);
			data.put(Keys.VALUE, startDate);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		} else {
			data.setParsingStatus(ParsingStatus.FAIL);
		}
	}

}

	// End of segment: .\udo\util\parser\edit\EditActionStartDate.java





	/**
	 * origin: .\udo\util\parser\edit\EditActionStartTime.java
	 */

package udo.util.parser.edit;

import java.util.Calendar;

import udo.util.parser.TimeGetter;
import udo.util.shared.Constants.Keys;
import udo.util.shared.EditField;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class EditActionStartTime implements EditActionField {

	/**
	 * This class handles the start time field
	 */
	
	public EditActionStartTime() {
		
	}

	@Override
	public void fill(String details, InputData data) {
		TimeGetter time = new TimeGetter();
		Calendar startTime = time.getTime(details);
		if (startTime != null) {
			data.put(Keys.FIELD, EditField.START_TIME);
			data.put(Keys.VALUE, startTime);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		} else {
			data.setParsingStatus(ParsingStatus.FAIL);
		}
	}


}

	// End of segment: .\udo\util\parser\edit\EditActionStartTime.java





	/**
	 * origin: .\udo\util\parser\edit\EditActionTitle.java
	 */

package udo.util.parser.edit;

import java.util.ArrayList;

import udo.util.shared.Constants.Keys;
import udo.util.shared.EditField;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class EditActionTitle implements EditActionField {

	/**
	 * This class handles the title field
	 */
	
	public EditActionTitle() {
		
	}

	@Override
	public void fill(String details, InputData data) {
		String title = getTitle(details);
		ArrayList<String> tags = getTags(details);
		if (title != null && !title.isEmpty()) {
			data.put(Keys.FIELD, EditField.TITLE);
			data.put(Keys.VALUE, title);
			data.put(Keys.HASHTAGS, tags);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		} else {
			data.setParsingStatus(ParsingStatus.FAIL);
		}
	}
	
	private String getTitle(String details) {
		String title = details.replaceAll("#", "");
		String parts[] = title.split(" ");
		String newTitle = "";
		for (int i=3; i< parts.length; i++) { 		// "edit 12345 title <new title>"
			newTitle = newTitle + parts[i] + " ";	// new title starts from index 3
		}
		newTitle = newTitle.trim();
		if (newTitle.length() != 0) {
			return newTitle;
		} else {
			return null;
		}
	}
	
	private ArrayList<String> getTags(String input) {
		ArrayList<String> tagArrayList = new ArrayList<String>();
		String tag;
		boolean hashTagFilled;
		String words[] = input.split(" ");
		for (String word : words) {
			hashTagFilled = word.length() > 1;
			if (word.startsWith("#") && hashTagFilled) {
				tag = word.replaceFirst("#", "");
				tagArrayList.add(tag);
			}
		}
		return tagArrayList;
	}

}

	// End of segment: .\udo\util\parser\edit\EditActionTitle.java





	/**
	 * origin: .\udo\util\parser\EditAction.java
	 */

package udo.util.parser;

import udo.util.parser.edit.EditActionDueDate;
import udo.util.parser.edit.EditActionDueTime;
import udo.util.parser.edit.EditActionEndDate;
import udo.util.parser.edit.EditActionEndTime;
import udo.util.parser.edit.EditActionField;
import udo.util.parser.edit.EditActionStartDate;
import udo.util.parser.edit.EditActionStartTime;
import udo.util.parser.edit.EditActionTitle;
import udo.util.shared.Command;
import udo.util.shared.Constants.Keys;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

/**
 * This class handles all editing done by the user.
 * Input recieve by this class is in the format: 
 * "edit <<uid>> <<field to edit>> <<new info>>"
 */

public class EditAction implements Action {
	
	String[] mFields = {
			mLang.getTITLE(),
			mLang.getSTART_TIME(), 
			mLang.getEND_TIME(), 
			mLang.getSTART_DATE(), 
			mLang.getEND_DATE(),
			mLang.getDUE_TIME(), 
			mLang.getDUE_DATE()};
	
	@Override
	public InputData run(Command type, String details) {
		InputData data = new InputData(type);
		int uid = getUid(details);
		String field = getField(details);
		
		if (uid != -1 && field != null) {
			data.put(Keys.UID, uid);
			updateField(field, data, details);
		} else {
			data.setParsingStatus(ParsingStatus.FAIL);
		}
		return data;
	}

	@Override
	public InputData run(Command type) {
		return null;
	}
	
	private void updateField(String field, InputData data, String details) {
		if (field.equals(mLang.getTITLE())) {
			setTitle(data, details);
			
		} else if (field.equals(mLang.getSTART_TIME())) {
			setStartTime(data, details);
			
		} else if (field.equals(mLang.getEND_TIME())) {
			setEndTime(data, details);
			
		} else if (field.equals(mLang.getSTART_DATE())) {
			setStartDate(data, details);
			
		} else if (field.equals(mLang.getEND_DATE())) {
			setEndDate(data, details);
			
		} else if (field.equals(mLang.getDUE_TIME())) {
			setDueTime(data, details);
			
		} else if (field.equals(mLang.getDUE_DATE())) {
			setDueDate(data, details);
			
		} else {
			// do nothing
		}
	}
	
	// check whether any of the value returned is null
	private void setTitle(InputData data, String details) {
		EditActionField title = new EditActionTitle();
		title.fill(details, data);
	}
	
	private void setStartTime(InputData data, String details) {
		EditActionField startTime = new EditActionStartTime();
		startTime.fill(details, data);
	}
	
	private void setEndTime(InputData data, String details) {
		EditActionField endTime = new EditActionEndTime();
		endTime.fill(details, data);
	}
	
	private void setStartDate(InputData data, String details) {
		EditActionField startDate = new EditActionStartDate();
		startDate.fill(details, data);
	}
	
	private void setEndDate(InputData data, String details) {
		EditActionField endDate = new EditActionEndDate();
		endDate.fill(details, data);
	}
	
	private void setDueTime(InputData data, String details) {
		EditActionField dueTime = new EditActionDueTime();
		dueTime.fill(details, data);
	}
	
	private void setDueDate(InputData data, String details) {
		EditActionField dueDate = new EditActionDueDate();
		dueDate.fill(details, data);
	}

	private int getUid(String details) {
		String[] words = details.split(" ");
		if (words.length > 1) {
			String uidString = words[1];
			int uid = -1;
			try {
				 uid = Integer.parseInt(uidString);
			} catch (NumberFormatException nfe) {
				
			}
			return uid;
		} else {
			return -1;
		}
	}
	
	private String getField(String details) {
		details = details.toLowerCase();
		for (int i = 0; i < mFields.length; i++) {
			if (details.contains(mFields[i])) {
				return mFields[i];
			}
		}
		return null;
	}
	
}

	// End of segment: .\udo\util\parser\EditAction.java





	/**
	 * origin: .\udo\util\parser\ExitAction.java
	 */

package udo.util.parser;

import udo.util.shared.Command;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class ExitAction  implements Action {

	/**
	 * This class handles the exit command.
	 * Input recieve by this class is in the format: 
	 * "exit"
	 */
	
	public ExitAction() {

	}

	@Override
	public InputData run(Command type, String input) {
		return null;
	}

	@Override
	public InputData run(Command type) {
		InputData exitInputData = new InputData(type);
		exitInputData.setParsingStatus(ParsingStatus.SUCCESS);
		return exitInputData;
	}

}

	// End of segment: .\udo\util\parser\ExitAction.java





	/**
	 * origin: .\udo\util\parser\list\ListActionAll.java
	 */

package udo.util.parser.list;

import udo.util.shared.Command;
import udo.util.shared.Constants.Keys;
import udo.util.shared.InputData;
import udo.util.shared.ListQuery;
import udo.util.shared.ParsingStatus;

public class ListActionAll implements ListActionCommand {

	/**
	 * This class handles the All field
	 */
	
	public ListActionAll() {
		
	}
	
	@Override
	public void fill(Command type, String details, InputData data) {
		data.put(Keys.QUERY_TYPE, ListQuery.ALL);
		data.setParsingStatus(ParsingStatus.SUCCESS);
	}

}

	// End of segment: .\udo\util\parser\list\ListActionAll.java





	/**
	 * origin: .\udo\util\parser\list\ListActionCommand.java
	 */

package udo.util.parser.list;

import udo.util.shared.Command;
import udo.util.shared.InputData;

public interface ListActionCommand {

	public void fill(Command type, String details, InputData data);
}

	// End of segment: .\udo\util\parser\list\ListActionCommand.java





	/**
	 * origin: .\udo\util\parser\list\ListActionDate.java
	 */

package udo.util.parser.list;

import java.util.Calendar;

import udo.util.parser.DateGetter;
import udo.util.shared.Command;
import udo.util.shared.Constants.Keys;
import udo.util.shared.InputData;
import udo.util.shared.ListQuery;
import udo.util.shared.ParsingStatus;

public class ListActionDate implements ListActionCommand {

	/**
	 * This class handles the date field
	 */
	
	public ListActionDate() {
		
	}

	@Override
	public void fill(Command type, String details, InputData data) {
		DateGetter listDate = new DateGetter();
		Calendar date = listDate.getDate(details);
		if (date != null) {
			data.put(Keys.QUERY_TYPE, ListQuery.DATE);
			data.put(Keys.QUERY_VALUE, date);	
			data.setParsingStatus(ParsingStatus.SUCCESS);
		} else {
			data.setParsingStatus(ParsingStatus.FAIL);
		}
	}

}

	// End of segment: .\udo\util\parser\list\ListActionDate.java





	/**
	 * origin: .\udo\util\parser\list\ListActionDone.java
	 */

package udo.util.parser.list;

import udo.util.shared.Command;
import udo.util.shared.InputData;
import udo.util.shared.ListQuery;
import udo.util.shared.ParsingStatus;
import udo.util.shared.Constants.Keys;

public class ListActionDone implements ListActionCommand {

	/**
	 * This class handles the done field
	 */
	
	public ListActionDone() {
		
	}

	@Override
	public void fill(Command type, String details, InputData data) {
		data.put(Keys.QUERY_TYPE, ListQuery.DONE);
		data.setParsingStatus(ParsingStatus.SUCCESS);

	}

}

	// End of segment: .\udo\util\parser\list\ListActionDone.java





	/**
	 * origin: .\udo\util\parser\list\ListActionHashtag.java
	 */

package udo.util.parser.list;

import java.util.ArrayList;

import udo.util.shared.Command;
import udo.util.shared.Constants.Keys;
import udo.util.shared.InputData;
import udo.util.shared.ListQuery;
import udo.util.shared.ParsingStatus;

public class ListActionHashtag implements ListActionCommand {

	/**
	 * This class handles the hashtag field
	 */
	
	public ListActionHashtag() {
		
	}

	@Override
	public void fill(Command type, String details, InputData data) {
		ArrayList<String> tags = getTags(details);
		if (!tags.isEmpty()) {
			data.put(Keys.QUERY_VALUE, tags.get(0));
			data.put(Keys.QUERY_TYPE, ListQuery.SINGLE_HASHTAG);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		} else {
			data.setParsingStatus(ParsingStatus.FAIL);
		}
	}
	
	private ArrayList<String> getTags(String input) {
		ArrayList<String> tagArrayList = new ArrayList<String>();
		String tag;
		boolean hashTagFilled;
		String words[] = input.split(" ");
		for (String word : words) {
			hashTagFilled = word.length() > 1;
			if (word.startsWith("#") && hashTagFilled) {
				tag = word.replaceFirst("#", "");
				tagArrayList.add(tag);
			}
		}
		return tagArrayList;
	}

}

	// End of segment: .\udo\util\parser\list\ListActionHashtag.java





	/**
	 * origin: .\udo\util\parser\ListAction.java
	 */

package udo.util.parser;

import udo.util.parser.list.ListActionAll;
import udo.util.parser.list.ListActionCommand;
import udo.util.parser.list.ListActionDate;
import udo.util.parser.list.ListActionDone;
import udo.util.parser.list.ListActionEvent;
import udo.util.parser.list.ListActionHashtag;
import udo.util.parser.list.ListActionPlan;
import udo.util.parser.list.ListActionTask;
import udo.util.shared.Command;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class ListAction implements Action {
	
	/**
	 * This class takes in the field to be displayed.
	 * Input recieve by this class is in the format: 
	 * "list <<field>>"
	 */
	
	String mFields[] = {"#", 
			mLang.getALL(), 
			mLang.getDONE(), 
			mLang.getEVENT(), 
			mLang.getTASK(), 
			mLang.getPLAN(), 
			"/", 
			mLang.getDAY(), 
			mLang.getTOMORROW()};

	@Override
	public InputData run(Command type, String details) {
		InputData data = new InputData(type);
		int field = getField(details);
		ListActionCommand list;
		switch (field) {
			case 0 :
				list = new ListActionHashtag();
				list.fill(type, details, data);
				break;
			case 1 :
				list = new ListActionAll();
				list.fill(type, details, data);
				break;
			case 2 :
				list = new ListActionDone();
				list.fill(type, details, data);
				break;
			case 3 :
				list = new ListActionEvent();
				list.fill(type, details, data);
				break;
			case 4 :
				list = new ListActionTask();
				list.fill(type, details, data);
				break;
			case 5 :
				list = new ListActionPlan();
				list.fill(type, details, data);
				break;
			case 6 :
				list = new ListActionDate();
				list.fill(type, details, data);
				break;
			case 7 :
				list = new ListActionDate();
				list.fill(type, details, data);
				break;
			case 8 :
				list = new ListActionDate();
				list.fill(type, details, data);
				break;
			default:
				data.setParsingStatus(ParsingStatus.FAIL);
				break;
		}
		return data;
	}

	@Override
	public InputData run(Command type) {
		return null;
	}
	
	private int getField(String input) {
		String field = input.toLowerCase();
		for (int i = 0; i < mFields.length; i++) {
			if (field.contains(mFields[i])) {
				return i;
			}
		}
		return 0;
	}

}

	// End of segment: .\udo\util\parser\ListAction.java





	/**
	 * origin: .\udo\util\parser\MarkAction.java
	 */

package udo.util.parser;

import udo.util.shared.Command;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;
import udo.util.shared.Constants.Keys;

public class MarkAction implements Action {

	/**
	 * This class takes in the items that marked completed.
	 * Input recieve by this class is in the format: 
	 * "done <<uid>>"
	 */
	
	public MarkAction() {
		
	}

	@Override
	public InputData run(Command type, String input) {
		InputData data = new InputData(type);
		int uid = extractUid(input);
		if (uid == -1) {
			data.setParsingStatus(ParsingStatus.FAIL);
		} else {
			data.put(Keys.UID, uid);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		}
		return data;
	}

	@Override
	public InputData run(Command type) {
		return null;
	}
	
	private boolean isInteger(String input) {
		try {
			Integer.parseInt(input);
			return true;
		} catch (Exception e) {
			return false;
		}
	}
	
	private int extractUid(String input) {
		String parts[] = input.split(" ");
		if (parts.length >= 2) {
			String uid = parts[1];
			if (isInteger(uid)) {
				int id = Integer.parseInt(uid);
				return id;
			}
		} 
		return -1;
	}

}

	// End of segment: .\udo\util\parser\MarkAction.java





	/**
	 * origin: .\udo\util\parser\SaveAction.java
	 */

package udo.util.parser;

import udo.util.shared.Command;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class SaveAction implements Action {

	/**
	 * This class handles the save command.
	 * Input recieve by this class is in the format: 
	 * "save"
	 */
	
	public SaveAction() {

	}

	@Override
	public InputData run(Command type) {
		InputData saveInputData = new InputData(type);
		saveInputData.setParsingStatus(ParsingStatus.SUCCESS);
		return saveInputData;
	}

	@Override
	public InputData run(Command type, String input) {
		return null;
	}

}

	// End of segment: .\udo\util\parser\SaveAction.java





	/**
	 * origin: .\udo\util\parser\SearchAction.java
	 */

package udo.util.parser;

import udo.util.shared.Command;
import udo.util.shared.Constants.Keys;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class SearchAction implements Action {

	public SearchAction() {
		
	}

	@Override
	public InputData run(Command type, String input) {
		InputData searchInputData = new InputData(type);
		if (isValidSearch(input)) {
			String searchString = getSearchQuery(input);
			searchInputData.put(Keys.SEARCH_QUERY, searchString);
			searchInputData.setParsingStatus(ParsingStatus.SUCCESS);
		} else {
			searchInputData.setParsingStatus(ParsingStatus.FAIL);
		}
		return searchInputData;
	}

	@Override
	public InputData run(Command type) {
		return null;
	}
	
	private String getSearchQuery(String input) {
		String parts[] = input.split(" ");
		String searchString = "";
		for (int i = 1; i < parts.length; i++) {
			searchString = searchString + parts[i] + " ";
		}
		return searchString;
	}
 
	private boolean isValidSearch(String input) {
		String parts[] = input.split(" ");
		if (parts.length >= 2) {
			return true;
		} else {
			return false;
		}
	}

}

	// End of segment: .\udo\util\parser\SearchAction.java





	/**
	 * origin: .\udo\util\parser\TimeGetter.java
	 */

package udo.util.parser;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class TimeGetter {
	
	/**
	 * This class takes returns a calendar object set to the first time it reads 
	 * from input. It takes in time of format hh:mma and hha
	 */

	private Calendar mTime;
	private String mTimeFormat[] = {"hh:mma", "hha"};

	public TimeGetter() {
		
	}
	
	/**
	 * Method returns the first time it reads from input.
	 * Time must not have space in-between
	 * @param input
	 * @return Calendar time object
	 */
	public Calendar getTime(String input) {
		decipherText(input);
		return mTime;
	}
	
	private void decipherText(String input) {
		int timeFormat = getTimeFormat(input);
		if (timeFormat == 0 || timeFormat == 1) {
			String timeString = getTimeString(input, timeFormat);
			mTime = formatTimeSubstring(timeString, timeFormat);
		} else {
			mTime = null;
		}
	}

	private String getTimeString(String input, int timeFormat) {
		switch (timeFormat) {
			case 0:
				return extractTimeWithMinutes(input);
			case 1:
				return extractTimeWithoutMinutes(input);
			default:
				return null;
		}
	}
	
	private boolean isInteger(String input) {
		try {
			Integer.parseInt(input);
			return true;
		} catch (Exception e) {
			return false;
		}
	}

	private String extractTimeWithMinutes(String input) {
		String timeString = input.toUpperCase();
		String time[] = timeString.split(" ");
		for (int i = 0; i < time.length; i++) {
			if (isValidTime(time[i])) {
				return time[i];
			}
		}
		return null;
	}

	private String extractTimeWithoutMinutes(String input) {
		String time[] = input.split(" ");
		for (int i = 0; i < time.length; i++) {
			if (isValidTime(time[i])){
				return time[i];
			}
		}
		return null;
	}

	private boolean isValidTime(String time) {
		time = time.toUpperCase();
		if (time.length() == 3 || time.length() == 4) { // e.g. 3pm, 12am
			String amPmString = time.substring(time.length() - 1);
			String hour = time.substring(0, 1);
			if (isInteger(hour) && amPmString.equals("M")) {
				return true;
			} else {
				return false;
			}
		} else if (time.length() == 6 || time.length() == 7) { // e.g. 3:45am, 12:45pm
			String amPmString = time.substring(time.length() - 1);
			String hour = time.substring(0, 1);
			if (isInteger(hour) && amPmString.equals("M")) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}

	private Calendar formatTimeSubstring(String timeString, int timeFormat) {
		Calendar cal = null;
		SimpleDateFormat format = new SimpleDateFormat(mTimeFormat[timeFormat]);
		Date date;
		if (timeString != null) {
			try {
				date = format.parse(timeString);
				cal = Calendar.getInstance();
				cal.setTime(date);
			} catch (ParseException parserException) {
				cal = null;
				return cal;
			}
		}
		return cal;
	}

	private int getTimeFormat(String input) {
		String parts[] = input.split(" ");
		for (int i = 0; i < parts.length; i++) {
			if (isValidTime(parts[i])) {
				if (parts[i].length() == 3 || 	// e.g. 3pm 
					parts[i].length() == 4) {	// e.g. 12pm
					return 1;
				} else {
					return 0;
				}
			}
		}
		return -1;
	}
}

	// End of segment: .\udo\util\parser\TimeGetter.java





	/**
	 * origin: .\udo\util\parser\ToggleDoneAction.java
	 */

package udo.util.parser;

import udo.util.shared.Command;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;
import udo.util.shared.Constants.Keys;

public class ToggleDoneAction implements Action {

	/**
	 * This class takes in the items that marked as not completed from the completed list.
	 * Input recieve by this class is in the format: 
	 * "toggle done <<uid>>"
	 */
	
	public ToggleDoneAction() {
		
	}

	@Override
	public InputData run(Command type, String input) {
		InputData data = new InputData(type);
		int uid = extractUid(input);
		if (uid == -1) {
			data.setParsingStatus(ParsingStatus.FAIL);	
		} else {
			data.put(Keys.UID, uid);
			data.setParsingStatus(ParsingStatus.SUCCESS);
		}
		return data;
	}

	@Override
	public InputData run(Command type) {
		return null;
	}

	private boolean isInteger(String input) {
		try {
			Integer.parseInt(input);
			return true;
		} catch (Exception e) {
			return false;
		}
	}
	
	private int extractUid(String input) {
		String parts[] = input.split(" ");
		if (parts.length >= 3) {
			String uid = parts[2];
			if (isInteger(uid)) {
				int id = Integer.parseInt(uid);
				return id;
			}
		} 
		return -1;
	}
}

	// End of segment: .\udo\util\parser\ToggleDoneAction.java





	/**
	 * origin: .\udo\util\parser\TrashAction.java
	 */

package udo.util.parser;

import udo.util.shared.Command;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class TrashAction implements Action {

	/**
	 * This class helps handle all input without command
	 */
	
	public TrashAction() {

	}

	@Override
	public InputData run(Command type, String input) {
		return null;
	}

	@Override
	public InputData run(Command type) {
		InputData trashInputData = new InputData(type);
		trashInputData.setParsingStatus(ParsingStatus.FAIL);
		return trashInputData;
	}

}

	// End of segment: .\udo\util\parser\TrashAction.java





	/**
	 * origin: .\udo\util\parser\UndoAction.java
	 */

package udo.util.parser;

import udo.util.shared.Command;
import udo.util.shared.InputData;
import udo.util.shared.ParsingStatus;

public class UndoAction implements Action {

	/**
	 * This class undo previous commands
	 * Input recieve by this class is in the format: 
	 * "undo"
	 */
	
	public UndoAction() {
		
	}

	@Override
	public InputData run(Command type) {
		InputData undoInputData = new InputData(type);
		undoInputData.setParsingStatus(ParsingStatus.SUCCESS);
		return undoInputData;
	}

	@Override
	public InputData run(Command type, String input) {
		return null;
	}

}

	// End of segment: .\udo\util\parser\UndoAction.java





